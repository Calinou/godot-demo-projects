[gd_resource type="ShaderMaterial" load_steps=3 format=2]

[ext_resource path="res://faceNormal.png" type="Texture" id=1]

[sub_resource type="Shader" id=3]
code = "shader_type canvas_item;

uniform sampler2D normal;

varying vec2 var1;

void vertex() {
	//pass the x1 in local sprite coordinates.
	//the sprite center (small red cross) is 0,0
	var1.xy = VERTEX;
}

void fragment() {
	// just pass the normal
	vec2 ywnormal = texture(normal, UV).wy * vec2(2.0, 2.0) - vec2(1.0, 1.0);
	NORMAL = vec3(ywnormal, sqrt(1.0 - (ywnormal.x * ywnormal.x) - (ywnormal.y * ywnormal.y)));
}

void light() {
	//the tile half size in pixels
	vec2 tile_vec=vec2(140, 70);
	//compute a 3D postion for the light
	vec3 light_3d = vec3(-LIGHT_VEC.x, LIGHT_HEIGHT, LIGHT_VEC.y);

	//rotate the normal map to the same coordinates as the pseudo-3d point
	//this could be optimized
	float r = asin(tile_vec.y / tile_vec.x);
	mat3 rot_mat = mat3(vec3(1, 0, 0), vec3(0, cos(r), -sin(r)), vec3(0, sin(r), cos(r)));
	vec3 n = rot_mat * NORMAL;
	n.y = -n.y;

	//compute diffuse light
	float dp = max(dot(normalize(n),-normalize(light_3d)), 0);
	LIGHT = vec4(vec3(dp), 1.0) * COLOR * LIGHT_COLOR;
}"

[resource]
shader = SubResource( 3 )
shader_param/normal = ExtResource( 1 )
